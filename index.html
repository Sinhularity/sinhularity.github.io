<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Coding 701</title>

  <!-- Google Font-->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&icon_names=home_max,menu,newspaper,person_book">

  <link rel="stylesheet" href="css/index-style.css">
</head>

<body>
  <div class="mobile-menu-btn">
    <span class="material-symbols-outlined">menu</span>
  </div>

  <header class="header-main">
    <!-- Logo -->
    <div class="logo">
      <a href="index.html">
        <img src="assets/logo.png" alt="Logo">
        <h2 class="logo-text"><span>Coding</span> 701</h2>
      </a>
    </div>

    <!-- Navigation Menu -->
    <nav>
      <ul class="nav-header">
        <li>
          <a href="https://github.com/Sinhularity/sinhularity.github.io" target="_blank">
            <span class="material-symbols-outlined">home_max</span>
            Home
          </a>
        </li>
        <li>
          <a href="https://sinhularity.github.io/minimalist-portfolio-json/" target="_blank">
            <span class="material-symbols-outlined">person_book</span>
            About me
          </a>
        </li>
        <li>
          <a href="https://www.google.com/search?q=artificial+intelligence&sca_esv=d4c3277b19e45af9&rlz=1C1CHZN_enMX1042MX1042&biw=868&bih=498&tbm=nws&sxsrf=AE3TifOMljy1m0A1TCbQXgEiAhHN7wDMzQ%3A1756069411114&ei=I36raMjdBqn1kPIPhKCyUA&oq=Artifici&gs_lp=Egxnd3Mtd2l6LW5ld3MiCEFydGlmaWNpKgIIADINEAAYgAQYsQMYQxiKBTINEAAYgAQYsQMYQxiKBTIIEAAYgAQYsQMyChAAGIAEGEMYigUyChAAGIAEGEMYigUyChAAGIAEGEMYigUyBRAAGIAEMgUQABiABDIKEAAYgAQYQxiKBTIKEAAYgAQYQxiKBUiyF1DZBViCEHAAeACQAQCYAWGgAb4GqgEBObgBA8gBAPgBAZgCCaAC4QbCAgsQABiABBixAxiDAcICDhAAGIAEGLEDGIMBGIoFwgIQEAAYgAQYsQMYQxiDARiKBcICBBAAGAOYAwCIBgGSBwM3LjKgB6YxsgcDNy4yuAfhBsIHBTAuNC41yAce&sclient=gws-wiz-news"
            target="_blank">
            <span class="material-symbols-outlined">newspaper</span>
            More news</a>
        </li>
      </ul>
    </nav>
  </header>



  <!-- Main Content -->
  <main class="main-content">
    <article class="main-article">
      <header class="article-header">
        <h1>Técnicas basadas en una especificación</h1>
        <h2 class="article-subtitle">Pruebas de caja negra</h2>
      </header>

      <div class="hero-image">
        <img src="/assets/Frieren.jpg" alt="Ilustración sobre debugging y programación" class="hero-img">
      </div>

      <section class="article-section" id="particion-equivalente">
        <h3 class="section-title">¿Qué es la partición equivalente?</h3>
        <div class="section-content">
          <p>
            La partición equivalente es una <strong>técnica de diseño de casos de prueba</strong> que divide el conjunto
            de datos de entrada en clases de datos equivalentes.
            El objetivo es reducir el número total de casos de prueba necesarios al seleccionar un representante de cada
            clase, asumiendo que todos los valores dentro de una clase se comportan de manera similar.
          </p>
        </div>

        <h4 class="subsection-title">¿Cómo se divide los datos en la partición equivalente?</h4>
        <div class="section-content">
          <p>
            Esta técnica divide los datos de entrada en dos campos: entradas <b>válidas</b> e <b>inválidas</b>.
            En otras palabras:
          </p>
          <ol class="content-list">
            <li>Si la condición de un valor de la partición A es verdadera, también deben serlo los demás valores de la
              partición A.</li>
            <li>Del mismo modo, si las condiciones de un valor de la partición B son falsas, los demás valores de la
              partición B también deben ser falsos.</li>
          </ol>

          <p>
            Una vez conocemos las clases válidas e inválidas, utilizamos las pautas para obtener los casos de prueba
            (entrada y salida):
          </p>

          <ol class="content-list">
            <li> Rango de Valores: Si una condición de entrada especifica un rango de valores, por ejemplo, entre 1 y 99
              donde cualquier número mayor a 99 o menor a 1 será una clase inválida.
              <div class="formula-container">
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mn>1</mn>
                  <mo>&lt;</mo>
                  <mi>n</mi>
                  <mo>&lt;</mo>
                  <mn>99</mn>
                </math>
              </div>
            </li>
            <li>Número de valores: Si alguna condición requiere la especificación del número de valores.</li>
            <li>Conjunto de valores: En caso de utilizar valores específicos como los ingresados en estructuras “enum”
              cualquier otro valor ingresado sería inválidos.</li>
          </ol>

          <p class="note">
            <em>
              Las pautas para clasificar varían de acuerdo con las necesidades en caso de ser necesario las clases y
              grupos pueden subdividirse aún más.
            </em>
          </p>
        </div>

        <h4 class="subsection-title">Ejemplo práctico</h4>
        <div class="section-content">
          <p>
            Supongamos que tenemos un programa que se encarga de calcular el precio final de un producto considerando
            descuentos y costos de envío según el tipo de transporte.
          </p>

          <div class="table-container">
            <table class="data-table">
              <thead>
                <tr>
                  <th>Variable</th>
                  <th>Clase de equivalencia</th>
                  <th>Estado</th>
                  <th>Valor</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Precio Total</td>
                  <td>Válida</td>
                  <td>Correcto</td>
                  <td>Total &gt; 100</td>
                </tr>
                <tr>
                  <td>Precio Total</td>
                  <td>Inválida</td>
                  <td>Incorrecto</td>
                  <td>Total &lt; 0</td>
                </tr>
                <tr>
                  <td>Precio Total</td>
                  <td>Inválida</td>
                  <td>Incorrecto</td>
                  <td>Valor no numérico</td>
                </tr>
                <tr>
                  <td>Descuento</td>
                  <td>Válida</td>
                  <td>Correcto</td>
                  <td>0 &lt;= descuento &lt;= 10</td>
                </tr>
                <tr>
                  <td>Descuento</td>
                  <td>Inválida</td>
                  <td>Incorrecto</td>
                  <td>Descuento &lt; 0 o Descuento &gt; 10</td>
                </tr>
                <tr>
                  <td>Transporte Envío</td>
                  <td>Válida</td>
                  <td>Correcto</td>
                  <td>Camión = 8, Avión = 14</td>
                </tr>
                <tr>
                  <td>Transporte Envío</td>
                  <td>Inválida</td>
                  <td>Incorrecto</td>
                  <td>Códigos diferentes a 8 o 14</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </section>

      <section class="article-section" id="valores-frontera">
        <h3 class="section-title">¿Qué es el análisis de valores de la frontera?</h3>
        <div class="section-content">
          <p>
            Al igual que la técnica anterior se trata de un tipo de prueba de caja negra. El análisis de valores a la
            frontera,
            también conocido como valores límites, es utilizado principalmente para detectar cualquier comportamiento
            incorrecto
            sobre el sistema. La prueba consiste como su nombre lo indica en las “fronteras” límites que garantizan que
            el
            software funcione correctamente.
          </p>
        </div>

        <div class="subsection-title">
          <h3>¿Cómo se aplican los valores en pruebas?</h3>
        </div>
        <div class="section-content">
          <p>
            Es común que los programadores cometan errores entorno a los límites, por ejemplo, al calcular los años.
            Cuando se
            utilizan condiciones como igual que (=), mayor que (&gt;), menor que (&lt;) o cuántas veces se debe ejecutar un
              bucle. </p>

              <p>Los pasos para aplicar este procedimiento son:</p>
              <ol class="content-list">
                <li>Primero es identificar los casos de prueba -> Identificar las particiones de equivalencia:
                  particiones válidas
                  e inválidas.</li>
                <li>Después detectamos los límites de cada una de las particiones. Supongamos que tenemos un programa
                  que solicita
                  la creación de una contraseña, pero esta deberá tener entre 8 hasta 16 caracteres. Podemos decir que
                  los límites
                  de partición válidos son 8 &lt;= Contraseña &lt;= 16 y a partir de ellos podemos comenzar a trabajar.
                </li>
                <li>Una vez tenemos definido los límites y las particiones, comenzamos con algunas variables como: un
                  valor
                  nominal, un valor mínimo, uno por debajo del mínimo, uno por debajo del máximo, el valor máximo (valor
                  límite).
                </li>
              </ol>
        </div>

        <h4 class="subsection-title">Ejemplo práctico</h4>
        <div class="section-content">
          <p>
            Tomando uno de los ejemplos de clase supongamos que tenemos una aplicación que tiene como objetivo medir la
            temperatura y dependiendo del intervalo en la temperatura este muestra un mensaje.
          </p>
          <p>Fragmento del código:</p>

          <div class="code-container">
            <pre><code>
            for (int temp : arrTemperaturas) {
              if (temp &lt; 30 || temp &gt; 45) {
                throw new RuntimeException("EL VALOR " + temp + " NO ES CORRECTO");
                }
            }
            
          // Más código
            
          // Checamos el valor de la temperatura promedio
          if (tempPromedio &lt; 36.5) { 
            return "Hipotermia" ; 
          } else if (tempPromedio &gt; 36.5 && tempPromedio &lt;= 37.4) {
            return "Normal" ; 
          } else if (tempPromedio &gt;= 37.5 && tempPromedio &lt;= 39.9) { 
            return "Hipertermia" ; 
          } else {
              return "Hiperpirexia" ; 
          }
            </code></pre>
          </div>

          <div class="image-container">
            <img src="/assets/Valoresfrontera.png" alt="Tabla de análisis de valores frontera para temperaturas" class="content-image">
          </div>
        </div>
      </section>
    </article>

    <!-- Sidebar -->
    <aside class="sidebar">
      <header class="sidebar-header">
        <h2>Cargando noticias...</h2>
      </header>
      <div class="news-container">
        <!-- News articles will be dynamically loaded here -->
      </div>
    </aside>
  </main>
  
  
  <script src="/js/breaking-news.js"></script>

  <!-- Footer -->
  <footer class="footer-main">
    <div class="footer-content">
      <div class="sources-section">
        <h3>Fuentes de información</h3>
        <div class="apa-citations">
          <p class="citation">
            <em>Boundary Value Analysis</em>. (s/f). Qable.Io. Recuperado el 9 de noviembre de 2024, de
            <a href="https://www.qable.io/blog/boundary-value-analysis" target="_blank">Qable.Io</a>
          </p>
          <p class="citation">
            Saxena, A. (s/f). <em> Equivalence partitioning: Step-by-step process for efficient test.</em> Recuperado el
            8 de
            noviembre de 2024, de
            <a href="https://testsigma.com/blog/equivalence-partitioning/" target="_blank">Testsigma.com</a>
          </p>
          <p class="citation">
            Singureanu, C. (s/f).<em>Boundary Value Analysis (BVA)- types, process, tools & more</em>.
            Recuperado el 8 de noviembre
            de 2024, de
            <a href="https://www.zaptest.com/boundary-value-analysis" target="_blank">Zaptest.com</a>
          </p>
          <p class="citation">
            Singureanu, C. (s/f).<em> Partición por equivalencia: proceso, enfoques, herramientas y más</em>.
            Recuperado el 8 de noviembre
            de 2024, de
            <a href="https://www.zaptest.com/es/particionamiento-de-equivalencia-en-pruebas-de-software-que-es-tipos-proceso-enfoques-herramientas-y-mas"
              target="_blank">Zaptest.com</a>
          </p>
          <p class="citation">
            Terrera, G. (2022, noviembre 9). <em>ISTQB CTFL v3.1. Cap 4 - Partición de Equivalencia - Parte I.
              TestingBaires</em>.
            <a href="https://testingbaires.com/istqb-ctfl-v3-1-cap-4-particion-de-equivalencia-parte-i/"
              target="_blank">Testingbaires.com</a>
          </p>
        </div>
      </div>
    </div>
  </footer>

  <!-- Mobile functions -->
  <script>
    // Mobile menu toggle functionality
    document.addEventListener("DOMContentLoaded", function () {
      const mobileMenuBtn = document.querySelector(".mobile-menu-btn");
      const header = document.querySelector(".header-main");

      mobileMenuBtn.addEventListener("click", function () {
        header.classList.toggle("mobile-active");
      });

      // Close mobile menu when clicking outside
      document.addEventListener("click", function (event) {
        if (
          !header.contains(event.target) &&
          !mobileMenuBtn.contains(event.target)
        ) {
          header.classList.remove("mobile-active");
        }
      });
    });
  </script>
</body>
</html>